![CF](http://i.imgur.com/7v5ASc8.png) LAB 8
=================================================

## Socket.io

### Author: Fletcher LaRue

### Links and Resources

* [repo](https://github.com/asdFletcher/08-socket.io)
* [travis]()
<!-- * [back-end](http://xyz.com)
* [front-end](http://xyz.com) -->

--- 
---
### Description:
Project for Code Fellows 401 to refactor the provided application using best practices for modularization, asynchronous file access, and test-ability.

The application currently uses a nested callback to accept a file from the user and perform various operations on it. It throws errors on failure and logs out success messages.

The task is to refactor the application to use events to surface errors and completion status, while also moving away from the big un-testable callback.



accept file name from CLI
convert contents to uppercase
write it back to the file system

console.log the status after writing
throw any errors

js doc for all functions
listener for 

server.js
- the socket.io server
- use port 3000
- listens for file-save
    - emit an event when it happens
- listens for file-error
    - emit an event when it happens


app.js
- reads in a file
    - makes changes to it
    - saves the data to the file
    - uses promises
    - has separate functions
    - File Reading/Writing/Uppercasing should happen in one module
    - Each operation should be in a separate function
    - Read/Write should be done in promises, not callbacks
- connected to server.js

logger.js
- listens for file-save
    - console.log the details when it happens
- listens for file-error
    - console.log the details when it happens

Initialization routine:
- start the server
- start the logger
- run the application
    - the application does not need to initialize the server or the logger 

---
### Files
#### `app.js`
#### `events.js`
#### `logger.js`
#### Test files
#### `app.test.js`
#### `logger.test.js`
---

### Modules
#### `modulename.js`
##### Exported Values and Methods for the following files:
#### `app.js`
- ###### `alterFile(<file name>)`

#### `logger.js`
These values are exported only for testing purposes. The file `logger.js` is imported into `app.js` so these functions can be accessed.
- ###### `writeSuccess(<file name>)`
- ###### `readFileError(<file name>)`
- ###### `writeFileError(<file name>)`

#### `events.js`
`Events.js` exports an event emitter. This is a common event emitter imported into `app.js` and `logger.js` and any other file that will need to listen for events generated by `app.js`.
- ###### `events`

### Setup
#### `.env` requirements
<!-- * `PORT` - Port Number
* `MONGODB_URI` - URL to the running mongo instance/db -->

#### Running the app
<!-- * `npm start`
* Endpoint: `/foo/bar/`
  * Returns a JSON object with abc in it.
* Endpoint: `/bing/zing/`
  * Returns a JSON object with xyz in it. -->

### Testing

The root folder in the repo holds the main app file:
`app.js`

Tests are written for the LinkedList class methods and can be found here:
`__tests__/app.test.js`

All testing for this class was done with Jest: 
* [Jest docs](https://jestjs.io/docs/en/getting-started)

Instructions for replicating the tests for this project are as follows:

* Clone the repo.
* Create a node runtime environment

    ```JavaScript
    npm init
    ```
    This will create a `package.json` file, a `package-lock.json` file.

* Install Jest

    ```JavaScript
    npm i jest
    ```

* Run jest

    ```JavaScript
    npm jest --verbose --coverage
    ```
    It is useful to bind this to the command:
    ```JavaScript
    npm test
    ```
    To do this, manually edit your package.json to include the following under the "scripts" attribute:
    ```Javascript
    "scripts": {
        "test": "jest --verbose --coverage",
        "test-watch": "jest --watchAll --verbose --coverage"
    }
    ```
    `test-watch` will re-run tests when the file is saved


---

### Dependencies

* Jest: `npm i jest` 
    * [Jest docs](https://jestjs.io/docs/en/getting-started)
    * testing
* JSDoc: `npm i jsdoc`
    * [JSDoc docs](http://usejsdoc.org/)
    * documentation
* uuid: `npm i uuid`
    * [uuid docs](https://www.npmjs.com/package/uuid)
    * for creating unique ID's for users
* require-directory:
    * [require-directory docs](https://www.npmjs.com/package/require-directory)
    * for requiring all files in a directory, not just single files


### Setup
#### `.env` requirements
* n/a

--- 

### TCP Protocol
##### Audiience: Code Fellows 301 students

#### TCP protocol is meant to ensure the following:
- all data is sent (no missing data)
- consistent speed of transfer (i.e. not broken up)
- data is re-assembled in order (not jumbled up)

These are all seemingly obvious requirements for sending and receiving data. And it turns out people have made a protocol for helping ensure that this happens: TCP.

#### The way in which it does this is:
- split your data into multiple pieces called packets 
- label each packet with a number
- give each packet a deadline for being received
- Re-send packets that are not acknowledged by the receiver
- Re-send other packets that the receiver asks for. This can be due to loss of data or corrupted data.
- The receiver re-assembles the data and delivers it to the user

